{"meta":{"title":"RRW_BLOG","subtitle":"Welcome to my Blog！","description":"","author":"Friend_Rrw","url":"http://1097872822.github.io","root":"/"},"pages":[{"title":"","date":"2020-05-06T17:23:29.992Z","updated":"2020-05-06T17:23:29.992Z","comments":true,"path":"bbs/index.html","permalink":"http://1097872822.github.io/bbs/index.html","excerpt":"","text":"layout: “bbs” title: “BBS” date: 2017-09-19 12:48:33 description: “欢迎交换友链，一起交流学习！” header-img: “img/lan.jpg” comments: true document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"about","date":"2020-05-06T10:04:25.000Z","updated":"2020-05-06T10:05:10.500Z","comments":true,"path":"about/index-1.html","permalink":"http://1097872822.github.io/about/index-1.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"about","date":"2020-05-05T08:28:08.000Z","updated":"2020-05-05T08:29:09.261Z","comments":true,"path":"about/index.html","permalink":"http://1097872822.github.io/about/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"contact","date":"2020-02-20T06:23:50.000Z","updated":"2020-05-06T17:35:11.783Z","comments":true,"path":"contact/index.html","permalink":"http://1097872822.github.io/contact/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"categories","date":"2020-05-06T10:01:50.000Z","updated":"2020-05-06T10:02:32.552Z","comments":true,"path":"categories/index.html","permalink":"http://1097872822.github.io/categories/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"friends","date":"2020-05-06T10:05:30.000Z","updated":"2020-05-06T10:05:51.792Z","comments":true,"path":"friends/index.html","permalink":"http://1097872822.github.io/friends/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"相册","date":"2020-05-10T14:23:27.654Z","updated":"2020-05-10T14:23:27.654Z","comments":true,"path":"galleries/index.html","permalink":"http://1097872822.github.io/galleries/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"tags","date":"2020-05-06T10:03:02.000Z","updated":"2020-05-06T10:03:42.195Z","comments":true,"path":"tags/index.html","permalink":"http://1097872822.github.io/tags/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"wuhan","date":"2020-05-10T14:15:26.426Z","updated":"2020-05-07T10:04:27.758Z","comments":true,"path":"galleries/wuhan/index.html","permalink":"http://1097872822.github.io/galleries/wuhan/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"chongqing","date":"2020-05-10T14:18:23.857Z","updated":"2020-05-07T10:05:05.148Z","comments":true,"path":"galleries/chongqing/index.html","permalink":"http://1097872822.github.io/galleries/chongqing/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"yichang","date":"2020-05-10T14:18:14.390Z","updated":"2020-05-07T10:04:43.421Z","comments":true,"path":"galleries/yichang/index.html","permalink":"http://1097872822.github.io/galleries/yichang/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"Javaee-base","slug":"Javaee-base","date":"2020-02-14T11:25:09.000Z","updated":"2020-07-14T11:48:08.323Z","comments":true,"path":"2020/02/14/javaee-base/","link":"","permalink":"http://1097872822.github.io/2020/02/14/javaee-base/","excerpt":"","text":"1.常用命令： dir 列出文件目录 md 创建目录 rd 删除目录 cd 进入目录 cd\\ 回到根目录 del 删除文件 del *.txt 删除目录所有txt文件 echo 想要写入的文本内容&gt;要写入的文件 java的核心机制： JVM 和 垃圾回收2.JDK &amp; JRE 与JVM关系： java.exe 编译文件 。class：字节码文件 java.exe： 运行文件 //第一个java程序 class Helloworld{ public static void main(String[] args){ System.out.println(\"HelloWrold!\"); } } 另外：vacode官方配置java环境文档3.java的变量： //其中Long型 定义要以 L 结尾： long abc = 123123L; //floaat 要加 F ： float abc = 123.123F; // char(字符) 与 string(字符串) 不同 char a = 'a'; //正确 char a = 'AB'; //错误 //char = '';不对 string = '';可以！ //另外 可以为 char = '\\n'; 或者 char = '\\t'; // “\\t” 相等于tab的展位。 char = '\\u0065'; //输出转义符即ascll码 \"A\"; 3.1 转换规则：//向高位转换： byte&lt;short&lt;int&lt;long&lt;float&lt;double byte a = 1; int b = 2; int c = a + b; //用较高位的int,或者用比int范围大的； //其中，byte short char 做运算时，结果应为 int 类型： byte a = 1 ; char b = 'A'; int c = a + b; //输出66 //强制类型转换： double a = 12.999; int b = (int)a; //使用int强转 输出 12，可能会出现精度损失,只是可能！ int a = 128; byte b = (byte)(a); //输出结果为-128 //自动提升： long a = 123123; //不加L 也可以，123123它属于int，用long接收，没问题，要是超过int就要加L； float a = 12.3; //不加F 报错！12.3是double，不能用float接收； 4.java 运算符：4.1算术、赋值、比较、逻辑、位运算、三元 运算符： 其中： 取余 % 的符号决定于被除数；int a = 10; int b = a++; //此处分先后++ -----分开写-------- int a = 10; a++; // 也可以是++a int b = a; int a = 4; int b = 3; String maxStr1 = (a > b) ? \"a大\":\"b大\"; String maxStr2 = (a > b) ? \"a大\": ((m == n) ? \"nm相等\" : \"n大\"); 优先级： 5.java的输入，需要用到Scanner:import java.util.Scanner; class ScannerTest{ public static void main(String[] args){ System.out.println(“请输入：”); Scanner scan = new Scanner(System.in); int num = scan.nextInt(); //此处为int,string为 string name = scan.next(); char为charAt() System.out.println(num); } } 5.1 java 的分支语句 switch-case语句：int num = 2; switch(num){ //可以是byte、short、char、shring、枚举类型.. 就是不可以放 布尔型; case 0: System.out.println(ZERO); break; case 1: System.out.println(ONE); break; case 2: System.out.println(TWO); break; default: System.out.println(ZERO); } 5.1 java的内嵌循环：for (int i=0;i&lt;5;i++){ for (int j = 0;j &lt;= 4 - i;j++){ System.out.print(\" \"); } for (int k = 0;k &lt; i + 1;k++){ System.out.print(\"# \"); } System.out.println(); } for (int i = 0;i &lt; 4;i++){ for (int j = 0;j &lt;= i + 1;j++){ System.out.print(\" \"); } for (int k = 0;k &lt; 4 - i;k++){ System.out.print(\"# \"); } System.out.println(); } //输出： # # # # # # # # # # # # # # # # # # # # # # # # # // 求100000以内的质数 class test{ public static void main(String[] args){ int i,j; long start = System.currentTimeMillis(); for (i=2;i&lt;=100000;i++){ for (j=2;j&lt;i;j++){ if (i % j == 0) break; } if (i == j){ System.out.print(j+\" \"); } long end = System.currentTimeMillis(); System.out.println(\"花时:\" + (end-start)); } } } //没有优化，花时2000毫秒左右 //优化后: class Helloworld{ public static void main(String[] args){ boolean isFlag = true; //标识i是否被除尽,一旦除尽,修改其值 long start = System.currentTimeMillis(); int count = 0; for (int i=2;i&lt;=100000;i++){ //for (int j=2;j&lt;i;j++){ for (int j=2;j&lt;Math.sqrt(i);j++){ if (i % j == 0){ isFlag = false; break; } } if (isFlag==true){ //System.out.print(i + \" \"); count++; } isFlag = true; //重置isFlag } long end = System.currentTimeMillis(); System.out.print(\"个数:\" + count); System.out.println(\"花时:\" + (end-start)); } //花时18毫秒！ 其中break 结束当前循环 continue是结束本次循环；且break后面不能有执行语句；continue后面可以;//break与continue都是默认结束最近的一个for //带标签的break： continue同理; Flag:for .... for .... break Flag; //结束带Flag的第一个for //应用到上一题的求质数: class Helloworld{ public static void main(String[] args){ long start = System.currentTimeMillis(); int count = 0; Flag:for (int i=2;i&lt;=100000;i++){ for (int j=2;j&lt;Math.sqrt(i);j++){ if (i % j == 0){ continue Flag; //其意就是如果i%j==0 直接跳出第二个循环，跳到带Flag标签的for； } } count++; } long end = System.currentTimeMillis(); System.out.print(\"个数:\" + count); System.out.println(\"花时:\" + (end-start)); } } //花时同样是18毫秒，但是代码量更少~ ###项目一参考#######项目一参考#### document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"get & post","slug":"get-post","date":"2020-02-02T01:25:00.000Z","updated":"2020-07-13T17:34:00.148Z","comments":true,"path":"2020/02/02/get-post/","link":"","permalink":"http://1097872822.github.io/2020/02/02/get-post/","excerpt":"","text":"后端入门了解目的：实现API 了解API 的get/post 以及它里面的 request、param、query和body框架：flask需要：python版本，flask依赖、虚拟环境[这里不花时间列出，需要自行百度哟~]【平台可以使用VScode 或者 pycharm，本文使用的是VScode】Flask参考网站1.开始：1、ctrl c - v 一下代码：#新建一个main.py，键入以下代码 #需要注意的是，此时应该在你的文件视图下会有_pycache_ 和 venv 这两个文件了，如下图： from flask import Flask app = Flask(__name__) @app.route('/') def hello_world(): return \"Hello RRW!\" #在终端键入命令： set FLASK_APP=main.py #Linux的是export FLASK...来指定FLASK_APP环境变量 flask run #别忘记cd到你的main.py文件哟，或者直接“选择文件在终端打开” 然后就会出现本地的一个5000端口的链接啦： Ctrl +点下链接 康康你的返回如下就没毛病了： “/”后面可以是name、age…等等 ，表示每一个api，可以用127.1/5000/name 来返回name接口的内容2 .GET &amp; POST:在平台下面会返回GET(浏览器默认)，那如果想要分会POST呢？ 这里会用到postman，来测试：#首先增加name的接口: @app.route('/name', methods=['GET','POST']) #可以是get，也可以是post，返回都是同样的内容 def get_name(): return \"ruanrongwang~\" 在浏览器请求127.1/5000/name 时 ，你同样会发现它是默认的get请求，但是在postman请求时呢？ 你会发现，当选择POST时，VScode给你返回的是POST的一个请求;2.1 JSON 结构化数据： 这样的目的是更方便的通过 它的（key，value） 获取“用户”的信息 name啊 age啊等等。2.2.1 前端怎么给后端发送数据？（get） 可以看到通过request.args.get 前端给后端发送了 name=RRW, 2.2.2 在post里该怎么发呢？ (form:表单提交) 2、数据库的搭建：直接上连接吧Define and Access the DatabaseApplication Setup 其中，SQLite是嵌入式的，不需要你再搭建另外的数据库服务器；2.1、数据库实例的创建;//首先 cd 到flaskr下 echo test> db.py //初始化数据库： echo test> schema.sql //后面按文档步骤来操作，两个文件的代码如下： #db.py: import sqlite3 import click from flask import current_app, g from flask.cli import with_appcontext def get_db(): if 'db' not in g: g.db = sqlite3.connect( current_app.config['DATABASE'], detect_types=sqlite3.PARSE_DECLTYPES ) g.db.row_factory = sqlite3.Row return g.db def init_db(): db = get_db() with current_app.open_resource('schema.sql') as f: db.executescript(f.read().decode('utf8')) def close_db(e=None): db = g.pop('db', None) if db is not None: db.close() @click.command('init-db') @with_appcontext def init_db_command(): \"\"\"Clear the existing data and create new tables.\"\"\" init_db() click.echo('Initialized the database.') def init_app(app): app.teardown_appcontext(close_db) app.cli.add_command(init_db_command) #schema.sql: DROP TABLE IF EXISTS userProfile; CREATE TABLE userProfile ( id INTEGER PRIMARY KEY RRWINCREMENT, username TEXT UNIQUE NOT NULL, fens INTEGER NOT NULL DEFAULT 0 ); #在 __init__.py里还得加上： from . import db db.init_app(app) 最后就是数据库创建：flask init-db //会看到 “Initialized the database.” 如下： 然后就可以使用数据库管理工具（我这里用的是Navicat）连接sqlite了： 可以看到自己在schema.sql中自己创建的表说明没得问题了： 2.2、工厂模式创建flask实例；//首先在文件目录下（终端）： mkdir flaskr //初始化： echo test> __init__.py //linux下是 touch __init__.py //得到如下目录文件： //然后环境变量设成flaskr这个package： set FLASK_APP=flaskr //设成开发环境： set FLASK_BW=development //运行： flask run //如下： 注意:运行的目录对不对（在FLASK-BILIBILI目录下），找不到“flaskr”这个包的话就会这样子的： 虽然你前面的步骤都没有报错，这可能就是解释性语言的特点吧~然后一个个@app的请求试试会不会no Found： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[],"author":"阮荣望"},{"title":"Data Warehouse","slug":"Data-Warehouse","date":"2019-02-02T01:25:00.000Z","updated":"2020-05-07T11:24:19.239Z","comments":true,"path":"2019/02/02/data-warehouse/","link":"","permalink":"http://1097872822.github.io/2019/02/02/data-warehouse/","excerpt":"","text":"==数据仓库==：数据仓库是一个面向主题的、集成的、相对稳定的、反映历史变化的数据集合，它用于支持企业或组织的决策分析处理。==与数据库的不同==：操作性数据库中的数据会经常的被增删改，而数据仓库的数据只是载入，然后提供查询功能。因此数据仓库中的数据更稳定，不易丢失。 数据仓库中存储历史数据，往往是几年前的数据，这些数据随时间不短累计，并且数据仓库中含有很多时间标识。 数据粒度不同 数据库存储的是操作型数据，是细节性的数据，是当前的数据，反映的是最后的修改结果。数据仓库是分析型的集成挥着汇总的数据，面向主题，保存着数据的所有历史状态—数据粒度问题。分析型数据操作往往关注的是综合性数据，但是操作型数据库中存放的是细节数据，如果在分析前对细节数据进行综合，会严重影响分析的效率。因此，为了克服以上问题，使两种数据操作都能够有效的进行，就产生了数据仓库。 数据生命周期不同。 数据库存的数据的生命周期比较短，不会保存很久的数据。数据仓库则需要历史数据来反映趋势的变化和数据分析。 建模方法不同。数据可以采用范式建模，不能有冗余。数据仓库的建模方法有DW范式建模（跟数据库的范式建模也不同）和DW维度建模等。可以存在冗余 时间敏感度不同数据库的数据要求及时性非常高，数据仓库可以容忍数据的一定的延迟 目标不同数据库主要面向业务处理的，而数据仓库则面向分析用户 操作不同： 两种数据处理模式对应着两类数据：操作型数据和分析型数据。​ 操作型数据处理主要应用于企业的日常事务处理工作，数据库中存放的是细节的数据，也是当前的数据，反映的是最近一次修改后的结果。对数据的操作主要是数据的增删查改。数据库中的数据是可以修改的。数据的组织以方便事务处理、提高事务处理性能为目标。分析型数据处理主要应用于企业的管理工作，数据库中主要存放的是历史数据和综合数据。对数据的操作主要集中在查询和统计分析，需要涉及大量数据，数据的组织方式以方面查询分析为主要目标，为了提高查询效率允许存在某种程度上的数据冗余。 根据其出现的先后顺序，主要分为2种模式：自顶向下（TOP-down）,自底向上（Bottom-up）.==自顶向下==开发企业数据仓库是从总体上把握整个数据仓库的规模、粒度的级别和元数据管理，是一种系统的解决方法，并能够最大限度地减少集成问题。然而，它费用高，需要长时间开发，并且缺乏灵活性，因为整个组织的共同数据模型达到一致是很困难的。==自底向上==设计、开发、部署独立的数据集市提供了灵活性，花费低，并能够得到快速的投资回报。但存在的问题是将分散的数据集市集成，形成一个一致的企业数据仓库并不容易。 一、 自顶向下（TOP-down）：这种模式首先把OLTP数据通过ETL汇集到数据仓库中，然后再把数据通过复制的方式推进各个数据集市中优点：1、数据来源固定，可以确保数据的完整性。2、数据格式与单位一致，可以确保跨越不同数据集市进行分析的正确性。3、数据集市可以保证有共享的字段。因为都是从数据仓库中分离出来的。缺点：1、对系统分析和设计人员的要求较高2、开发周期长，系统复杂度高 自底向上（Bottom-up）：这种模式首先将OLTP数据通过ETL汇集到数据集市中，然后通过复制的方式提升到数据仓库中。优点：1、由于首先构建数据集市的工作相对简单，所以容易成功。2、这种模式也是实现快速数据传送的原型。3、数据仓库和数据集市：缺点：1、由于方法的演变性质，信息系统难以实现其整体性2、由于系统未进行全局规划，系抄统的数据一致性和完整性难以保证3、为了达到系统的性能要求，往往不得不重新调整系统，甚至要重新设计系统4、由于系统实施的分散性和演变性，系统框架难以把握，集成难度高，因而与企业目标的联系往往是间接 的，系 统往往难以支持企业的整体战略目标5、在大型管理信息系统的开发中，容易造成系统结构不合理、各部分失调等问题6、仍然需要采用软件生命周期法对系统进行结构化分析 所以，具体到本材料中，我认为自底向上的构建方式更加合适！ ==3NF 关系模式设计==：每个实体作为一张表，每个多端的实体增加另外一端的主键作为外键，即可。[首先分单主键表和联合主键表分析：单主键表的“部门表”、“读者表”、“级别表”、“馆藏图书表”和“书目表”中，单主键并不考虑“2NF”情况，即他们都满足第一范式，然后再看关联主键是否满足”3NF”，通过观察，题目中的数据表都满足三个范式，所以易建立3NF关系模式如下]： 部门（部门编号、全称、简称）借书记录（读者编号、图书条码、借书日期、到期日期、归还日期）馆藏图书（图书条码、书目编号、卷号、年份、价格）书目（书目编号、分类号、出版年、语种、书名及作者、出版地、出版社、出版日期）读者（读者编号、部门编号、级别、性别、出生日期、办证日期）级别（级别、全称、简称）预约记录（书目编号、读者编号、预约日期、取消日期、完成日期） 【其实范式的规范化就是解决“数据冗余”的过程，整个数据表关系其实大致已经没有冗余，照写就是了】 ==维度表与事实表：== 维度基本设计方法： ==设计步骤：==第一步 选取业务处理第二步 定义粒度第三步 选定维度第四步 确定事实==在一个设计合理的维度模型中，维度表有许多列或者属性，这些属性给出对维度表的行所进行的描述。应该尽可能多地包括一些富有意义的文字性描述。====在事实表的设计时，一定要注意一个事实表只能有一个粒度，不能将不同粒度的事实建立在同一张事实表中。==数据仓库中常见的模型有：范式建模，雪花模型，星型建模，事实星座模型. ==星型模型==是数据集市维度建模中推荐的建模方法。星型模型是以事实表为中心，所有的维度表直接连接在事实表上，像星星一样。星型模型的特点是数据组织直观，执行效率高。因为在数据集市的建设过程中，数据经过了预处理，比如按照维度进行了汇总，排序等等，数据量减少，执行的效率就比较高。==雪花模型==也是维度建模中的一种选择。雪花模型的维度表可以拥有其他维度表的，虽然这种模型相比星型模型更规范一些，但是由于这种模型不太容易理解，维护成本比较高，而且性能方面需要关联多层维表，性能也比星型模型要低。所以一般不是很常用。==第三范式建模==是在数据库建模中使用的建模方法，特点是体系化，扩展性好，避免冗余，避免更新异常。所以，在数据仓库的EDW层建模中，我们也提倡使用第三范式建模。但是数据仓库的集成和反映历史变化的特征意味着数据量非常之大，表和表之间的关联效率比较低，所以有些时候完全规范的范式建模并不是最好的选择，通常我们会选择非规范化处理，增加一些冗余的字段来避免表之间关联的次数，这样会节约大量的时间。雪花模型是介于星型模型和范式建模之间的。个人理解，范式建模和雪花模型的区别在于雪花模型在维度上也是有冗余的。例如雪花模型例图的地域维度不符合第三范式，因为地域维度中存在传递依赖，城市-省级-国家-地域。==星座模型==是星型模型延伸而来，星型模型是基于一张事实表的，而星座模型是基于多张事实表的，而且共享维度信息。 通过构建一致性维度，来建设星座模型，也是很好的选择。比如同一主题的细节表和汇总表共享维度，不同主题的事实表，可以通过在维度上互相补充来生成可以共享的维度。 度量、粒度、事实表、维度、维度分析： ==维度建模：== ==维度模型优点：== 数据冗余小（因为很多具体的信息都存在相应的维度表中了，比如用户信息就只有一份） 结构清晰（表结构一目了然） 便于做OLAP分析（数据分析用起来会很开心） 增加使用成本，比如查询时要关联多张表 数据不一致，比如用户发起购买行为的时候的数据，和我们维度表里面存放的数据不一致 ==第四题答：==由题意应该知道：要满足对借还和预约数据的多维分析，则应该设计的是星座模型的多维度表： ==数据集市DM：== ==抽取、转换、加载过程的目的是为决策支持应用提供一个单一的、权威数据源。== DB、DW、DM、DOS 联系、区别：==数据库==：传统的关系型数据库的主要应用，主要是基本的、日常的事务处理，例如银行交易。==数据仓库==：数据仓库系统的主要应用主要是OLAP（On-Line Analytical Processing），支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果。 数据仓库特征：*效率足够高，要对进入的数据快速处理。*数据质量高，数据仓库是提供很多决策需要的数据支撑，DW的数据应该是唯一的具有权威性的数据，企业的所有系统只能从DW取数据，所以需要定期对DW里面的数据进行质量审，保证DW里边数据的唯一、权威、准确性。*扩展性，企业业务扩展和降低企业建设数据仓库的成本考虑*面向主题，数据仓库中的数据是按照一定的主题域进行组织的，每一个主题对应一个宏观的分析领域，数据仓库排除对决策无用的数据，提供特定主题的简明视图。*数据仓库主要提供查询服务，并且需要查询能够及时响应*DW的数据也是只允许增加不允许删除和修改，数据仓库主要是提供查询服务，删除和修改在分布式系统. ==数据处理大致可以分成两大类==：联机事务处理OLTP（on-line transaction processing）、联机分析处理OLAP（On-Line Analytical Processing）。 ==OLTP与OLAP：==OLTP是传统的关系型数据库的主要应用，主要是基本的、日常的事务处理，例如银行交易。OLAP是数据仓库系统的主要应用，支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果。OLTP 系统强调数据库内存效率，强调内存各种指标的命令率，强调绑定变量，强调并发操作；OLAP 系统则强调数据分析，强调SQL执行市场，强调磁盘I/O，强调分区等。 ODS和ODS的工作过程ODS（操作性数据）：ODS：是一个面向主题的、集成的、可变的、当前的细节数据集合，用于支持企业对于即时性的、操作性的、集成的全体信息的需求。工作过程：生产系统中的运营数据通过ETL（抽取、转换、装载）过程进人到ODS中，生产系统之间准实时的数据交换由ODS系统完成，ODS系统同时还将整合好的生产系统下的运营数据通过ETL等方式传送到EDW中，完成运营数据从操作环境进人到分析环境的过程。 特征：·ODS直接存放从业务抽取过来的数据，这些数据从结构和数据上与业务系统保持一致，降低了数据抽取的复杂性。·转移一部分业务系统的细节查询功能，因为ODS存放的数据与业务系统相同，原来有业务系统产生的报表，现在可以从ODS中产生。·完成数据仓库中不能完成的功能，ODS存放的是明细数据，数据仓库DW或数据集市DM都存放的是汇聚数据，ODS提供查询明细的功能。·ODS数据只能增加不能修改，而且数据都是业务系统原样拷贝，所以可能存在数据冲突的可能，解决办法是为每一条数据增加一个时间版本来区分相同的数据。 DM(Data Mart)：DM(Data Mart) 数据集市,为了特定的应用目的或应用范围，而从数据仓库中独立出来的一部分数据，也可称为部门数据或主题数据。面向应用。 特征：·DM结构清晰，针对性强，扩展性好，因为DM仅仅是单对一个领域而建立，容易维护修改·DM建设任务繁重，公司有众多业务，每个业务单独建立表。·DM的建立更多的消耗存储空间，单独一个DM可能数据量不大，但是企业所有领域都建立DM这个数据量就会增加多倍。 ODS与DW的区别主要有以下几点：1、数据的当前性ODS包括的是当前或接近当前的数据，ODS反映的是当前业务条件的状态，ODS的设计与用户或业务的需要是有关联的，而DW则是更多的反映业务条件的历史数据。 2、数据的更新或加载ODS中的数据是可以进行修改的，而DW中的数据一般是不进行更新的。ODS的更新是根据业务的需要进行操作的，而没有必要立即更新，因此它需要一种实时或近实时的更新机制。另外，DW中的数据是按照正常的或预先指定的时间进行数据的收集和加载的。 3、数据的汇总性ODS主要是包括一些细节数据，但是由于性能的需要，可能还包括一些汇总数据，如果包括汇总数据，可能很难保证数据的当前性和准确性。ODS中的汇总数据生命周期比较短，所以可称作为动态汇总数据，如果细节数据经过了修改，则汇总数据同样需要修改。而DW中的数据可称为静态的汇总数据。 4、数据建模ODS是站在记录层面访问的角度而设计的，DW或DM则是站在结果集层面访问的角度而设计的。ODS支持快速的数据更新，DW作为一个整体是面向查询的。 5、查询的事务ODS中的事务操作比较多，可能一天中会不断的执行相同的事务，而DW中事务的到达是可以预测的。 6、用途ODS用于每一天的操作型决策，是一种短期的；DW可以获取一种长期的合作广泛的决策。ODS是策略型的，DW是战略型的。 7、用户ODS主要用于策略型的用户，比如保险公司每天与客户交流的客服；而DW主要用于战略型的用户，比如公司的高层管理人员。 8、数据量（主要区别之一）ODS只是包括当前数据，而DW存储的是每一个主题的历史快照； ==数据挖掘的流程==数据挖掘(Knowledge Discovery in Database)数据库中知识发现，简称KDD。在数据挖掘中有几个非常中要的任务分别是分类，聚类，预测和关系分析。 1.分类： 就是通过训练集得到一个分类模型，然后用这个模型可以对其他数据进行分类。 ​ 训练集和测试集的概念： 一般来说数据可以划分为训练集和测试集。训练集是用来给机器做训练的，通常是人们整理好训练数据，以及这些数据对应的分类标识。通过训练，机器就产生了自我分类的模型，然后机器就可以拿着这个分类模型，对测试集中的数据进行分类预测。同样如果测试集中，人们已经给出了测试结果，我们就可以用测试结果来做验证，从而了解分类器在测试环境下的表现。 2.聚类： 人以群分，物以类聚。聚类就是将数据自动聚类成几个类别，聚到一起的相似度大，不在一起的差异性大。我们往往利用聚类来做数据划分。 3.预测： 就是通过当前和历史数据来预测未来趋势，它可以更好地帮助我们识别机遇和风险。 4.关系分析： 就是发现数据中的关联规则，它被广泛应用在购物篮分析，或事务数据分析中。比如某宝中的物品绑定推送。 数据库中知识发现(KDD)过程：输入数据 –&gt; 数据预处理(特征选择，维规约，规范化，选择数据子集) –&gt; 数据挖掘 –&gt; 后处理(模式过滤，可视化，模式表示) –&gt; 信息 数据预处理时进行的步骤： 1.数据清洗 主要是为了去除重复数据，去噪声（即干扰数据）以及填充缺失值。 2.数据集成 是将多个数据源中的数据存放在一个统一的数据存储中。 3.数据变换 就是将数据转换成适合数据挖掘的形式。比如，通过归一化将属性数据按照比例缩放，这样就可以将数值落入一个特定的区间内，比如 0~1 之间。 数据仓库分层： ==如何分层== 结合Inmon和Kimball的集线器式和总线式的数据仓库的优点，分层为ODS【-MID】-DW-DM-OLAP/OLAM/app ODS层是将OLTP数据通过ETL同步到数据仓库来作为数据仓库最基础的数据来源。在这个过程中，数据经过了一定的清洗，比如字段的统一，脏数据的去除等，但是数据的粒度是不会变化的。ODS层的数据可以只保留一定的时间。 MID中间层是采用Inmon集线器架构的方式，使用范式建模（贴源）的方法。这一层主要是做规范化的事情，比如应用库表非规范化，字段格式复杂（json格式）需做一些处理。这一层不是必须有的。也不会对外开放使用。范式建模保证了数据一致性、唯一性、正确性。 DW-DM层是采用Kimball的总线式的数据仓库架构，针对部门（比如财务部门）或者某一主题（比如商户、用户），通过维度建模（推荐星型模型），构建一致性维度，原子粒度的数据是DW层，按照实体或者主题经过一定的汇总，建设数据集市模型。数据集市可以为OLAP提供服务。 ==为什么要分层== 空间换时间。通过建设多层次的数据模型供用户使用，避免用户直接使用操作型数据，可以更高效的访问数据。 把复杂问题简单化。讲一个复杂的任务分解成多个步骤来完成，每一层只处理单一的步骤，比较简单和容易理解。而且便于维护数据的准确性，当数据出现问题之后，可以不用修复所有的数据，只需要从有问题的步骤开始修复。 便于处理业务的变化。随着业务的变化，只需要调整底层的数据，对应用层对业务的调整零感知. ==分层的价值== 高效的数据组织形式【易维护】面向主题的特性决定了数据仓库拥有业务数据库所无法拥有的高效的数据组织形式，更加完整的数据体系，清晰的数据分类和分层机制。因为所有数据在进入数据仓库之前都经过清洗和过滤，使原始数据不再杂乱无章，基于优化查询的组织形式，有效提高数据获取、统计和分析的效率。 **时间价值【高性能】 **数据仓库的构建将大大缩短获取信息的时间，数据仓库作为数据的集合，所有的信息都可以从数据仓库直接获取，数据仓库的最大优势在于一旦底层从各类数据源到数据仓库的ETL流程构建成型，那么每天就会有来自各方面的信息通过自动任务调度的形式流入数据仓库，从而使一切基于这些底层信息的数据获取的效率达到迅速提升。从应用来看，使用数据仓库可以大大提高数据的查询效率，尤其对于海量数据的关联查询和复杂查询，所以数据仓库有利于实现复杂的统计需求，提高数据统计的效率。 集成价值【简单化】 数据仓库是所有数据的集合，包括日志信息、数据库数据、文本数据、外部数据等都集成在数据仓库中，对于应用来说，实现各种不同数据的关联并使多维分析更加方便，为从多角度多层次地数据分析和决策制定提供的可能。 历史数据【历史性】 记录历史是数据仓库的特性之一，数据仓库能够还原历史时间点上的产品状态、用户状态、用户行为等，以便于能更好的回溯历史，分析历史，跟踪用户的历史行为，更好地比较历史和总结历史，同时根据历史预测未来。 ==星型模型 与 雪花模型 的对比与相同点：== 1.应用不同：==星型模型==的设计方式主要带来的好处是能够提升查询效率，因为生成的事实表已经经过预处理，主要的数据都在事实表里面，所以只要扫描实时表就能够进行大量的查询，而不必进行大量的join，其次维表数据一般比较少，在join可直接放入内存进行join以提升效率，除此之外，星型模型的事实表可读性比较好，不用关联多个表就能获取大部分核心信息，设计维护相对比较简答。==雪花模型==的设计方式是比较符合数据库范式的理念，设计方式比较正规，数据冗余少，但在查询的时候可能需要join多张表从而导致查询效率下降，此外规范化操作在后期维护比较复杂。2.共同点： 非标准化设计 无数据完整性（注意数据更新与增加） 3.特点比较： 4.==两者对比：==星型模型因为数据的冗余所以很多统计查询不需要做外部的连接，因此一般情况下效率比雪花型模型要高。在冗余可以接受的前提下，实际运用中星型模型使用更多，也更有效率。 在雪花模型中，数据模型的业务层级是由一个不同维度表主键-外键的关系来代表的。而在星形模型中，所有必要的维度表在事实表中都只拥有外键。 总结 雪花模型使得维度分析更加容易雪花模型使得维度分析更加容易，比如“针对特定的广告主，有哪些客户或者公司在线的？”星型模型用来做指标分析更适合，比如“给定的一个客户他们的收入是多少？” 星星模型 对比 雪花模型 ER 建模与 维度建模： ==数据治理==(DataGovernance)，是企业数据治理部门发起并推行的，关于如何制定和实施针对整个企业内部数据的商业应用和技术管理的一系列政策和流程。数据治理是一套持续改善管理机制，通常包括了数据架构组织、数据模型、政策及体系制定、技术工具、数据标准、数据质量、影响度分析、作业流程、监督及考核等内容。“数据治理是目前一个比较新兴的、正在发展的学科，目前业界对它的定义还不完全一样。”数据治理涉及的IT技术主题包括元数据管理、主数据管理、数据质量、数据集成、监控与报告等。 ==数据挖掘：==https://zhuanlan.zhihu.com/p/99363553https://zhuanlan.zhihu.com/p/99167118 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[],"author":"阮荣望"},{"title":"Go语言","slug":"Go语言","date":"2018-09-07T01:25:00.000Z","updated":"2020-05-06T12:32:50.825Z","comments":true,"path":"2018/09/07/go-yu-yan/","link":"","permalink":"http://1097872822.github.io/2018/09/07/go-yu-yan/","excerpt":"","text":"一、GO入门url ：老师博客1、下载/查看版本： 2、配置Go path： 3、安装编译器VS CODEVS Code[官方下载地址] ：https://code.visualstudio.com/Download 工具包下载：1、先在cmd里敲一下：go env -w GOPROXY=https://goproxy.cn,direct 2、操作下： 或者 ：(https://www.cnblogs.com/xll970105/p/11906899.html)完成后： 二、编译 &amp; 入门：1、编译：go build：在项目下执行；go run：执行脚本文件；go install表示安装的意思，它先编译源代码得到可执行文件，然后将可执行文件移动到GOPATH的bin目录下。因为我们的环境变量中配置了GOPATH下的bin目录，所以我们就可以在任意地方直接执行可执行文件了。1.1跨平台编译默认我们go build的可执行文件都是当前操作系统可执行的文件，如果我想在windows下编译一个linux下可执行文件，那需要怎么做呢？ 只需要指定目标操作系统的平台和处理器架构即可： SET CGO_ENABLED=0 // 禁用CGO SET GOOS=linux // 目标平台是linux SET GOARCH=amd64 // 目标处理器架构是amd64 使用了cgo的代码是不支持跨平台编译的 然后再执行go build命令，得到的就是能够在Linux平台运行的可执行文件了。 Mac 下编译 Linux 和 Windows平台 64位 可执行程序：CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build Linux 下编译 Mac 和 Windows 平台64位可执行程序：CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build Windows下编译Mac平台64位可执行程序：SET CGO_ENABLED=0 SET GOOS=darwin SET GOARCH=amd64 go build 2、变量和常量：2.1声明var name string var age int var isOk bool 同等于 var ( name string age int isOk bool ) 2.2短变量声明在函数内部，可以使用更简略的 := 方式声明并初始化变量。（注意不可以在函数外使用） package main import ( \"fmt\" ) // 全局变量m var m = 100 func main() { n := 10 m := 200 // 此处声明局部变量m fmt.Println(m, n) } 2.3 iota iota是go语言的常量计数器，只能在常量的表达式中使用。 iota在const关键字出现时将被重置为0。const中每新增一行常量声明将使iota计数一次(iota可理解为const语句块中的行索引)。 使用iota能简化定义，在定义枚举时很有用。 举个例子： const ( n1 = iota //0 n2 //1 n3 //2 n4 //3 ) 2.4几个常见的iota示例:使用_跳过某些值 const ( n1 = iota //0 n2 //1 _ n4 //3 ) iota声明中间插队 const ( n1 = iota //0 n2 = 100 //100 n3 = iota //2 n4 //3 ) const n5 = iota //0 定义数量级 （这里的&lt;&lt;表示左移操作，1&lt;&lt;10表示将1的二进制表示向左移10位，也就是由1变成了10000000000，也就是十进制的1024。同理2&lt;&lt;2表示将2的二进制表示向左移2位，也就是由10变成了1000，也就是十进制的8。） const ( _ = iota KB = 1 &lt;&lt; (10 * iota) MB = 1 &lt;&lt; (10 * iota) GB = 1 &lt;&lt; (10 * iota) TB = 1 &lt;&lt; (10 * iota) PB = 1 &lt;&lt; (10 * iota) ) 多个iota定义在一行 const ( a, b = iota + 1, iota + 2 //1,2 c, d //2,3 e, f //3,4 ) 3、数字类型：其中，uint8就是我们熟知的byte型，int16对应C语言中的short型，int64对应C语言中的long型。 类型 描述 uint8 无符号 8位整型 (0 到 255) uint16 无符号 16位整型 (0 到 65535) uint32 无符号 32位整型 (0 到 4294967295) uint64 无符号 64位整型 (0 到 18446744073709551615) int8 有符号 8位整型 (-128 到 127) int16 有符号 16位整型 (-32768 到 32767) int32 有符号 32位整型 (-2147483648 到 2147483647) int64 有符号 64位整型 (-9223372036854775808 到 9223372036854775807) 3.1数字字面量语法（Number literals syntax）v := 0b00101101， 代表二进制的 101101，相当于十进制的 45。 v := 0o377，代表八进制的 377，相当于十进制的 255。 v := 0x1p-2，代表十六进制的 1 除以 2²，也就是 0.25。 而且还允许我们用 _ 来分隔数字，比如说：v := 123_456 等于 123456。3.2打印浮点数时，可以使用fmt包配合动词%f，代码如下：package main import ( \"fmt\" \"math\" ) func main() { fmt.Printf(\"%f\\n\", math.Pi) fmt.Printf(\"%.2f\\n\", math.Pi) } 3.3复数complex64和complex128 var c1 complex64 c1 = 1 + 2i var c2 complex128 c2 = 2 + 3i fmt.Println(c1) fmt.Println(c2) 3.4布尔型Go语言中以bool类型进行声明布尔型数据，布尔型数据只有true（真）和false（假）两个值。 布尔类型变量的默认值为false。 Go 语言中不允许将整型强制转换为布尔型.（C中可以 false=0，true=1） 布尔型无法参与数值运算，也无法与其他类型进行转换。 3.5字符串转义符Go 语言的字符串常见转义符包含回车、换行、单双引号、制表符等，如下表所示。 转义符 含义 \\r 回车符（返回行首） \\n 换行符（直接跳到下一行的同列位置） \\t 制表符 \\' 单引号 \\\" 双引号 \\\\ 反斜杠 举个例子，我们要打印一个Windows平台下的一个文件路径： package main import ( \"fmt\" ) func main() { fmt.Println(\"str := \\\"c:\\\\Code\\\\lesson1\\\\go.exe\\\"\") } 3.5.1字符串的常用操作 方法 介绍 len(str) 求长度 +或fmt.Sprintf 拼接字符串 strings.Split 分割 strings.contains 判断是否包含 strings.HasPrefix,strings.HasSuffix 前缀/后缀判断 strings.Index(),strings.LastIndex() 子串出现的位置 strings.Join(a[]string, sep string) join操作 3.6byte和rune类型组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。 字符用单引号（’）包裹起来，如： var a := '中' var b := 'x' Go 语言的字符有以下两种： uint8类型，或者叫 byte 型，代表了ASCII码的一个字符。 rune类型，代表一个 UTF-8字符。 当需要处理中文、日文或者其他复合字符时，则需要用到rune类型。rune类型实际是一个int32。 Go 使用了特殊的 rune 类型来处理 Unicode，让基于 Unicode 的文本处理更为方便，也可以使用 byte 型进行默认字符串处理，性能和扩展性都有照顾。 // 遍历字符串 func traversalString() { s := \"hello沙河\" for i := 0; i &lt; len(s); i++ { //byte fmt.Printf(\"%v(%c) \", s[i], s[i]) } fmt.Println() for _, r := range s { //rune fmt.Printf(\"%v(%c) \", r, r) } fmt.Println() } 输出： 104(h) 101(e) 108(l) 108(l) 111(o) 230(æ) 178(²) 153() 230(æ) 178(²) 179(³) 104(h) 101(e) 108(l) 108(l) 111(o) 27801(沙) 27827(河) 因为UTF8编码下一个中文汉字由3~4个字节组成，所以我们不能简单的按照字节去遍历一个包含中文的字符串，否则就会出现上面输出中第一行的结果。 字符串底层是一个byte数组，所以可以和[]byte类型相互转换。字符串是不能修改的 字符串是由byte字节组成，所以字符串的长度是byte字节的长度。 rune类型用来表示utf8字符，一个rune字符由一个或多个byte组成。 3.6.1修改字符串要修改字符串，需要先将其转换成[]rune或[]byte，完成后再转换为string。无论哪种转换，都会重新分配内存，并复制字节数组。 func changeString() { s1 := \"big\" // 强制类型转换 byteS1 := []byte(s1) byteS1[0] = 'p' fmt.Println(string(byteS1)) s2 := \"白萝卜\" runeS2 := []rune(s2) runeS2[0] = '红' fmt.Println(string(runeS2)) } 3.7类型转换Go语言中只有强制类型转换，没有隐式类型转换。该语法只能在两个类型之间支持相互转换的时候使用。 强制类型转换的基本语法如下： T(表达式) 其中，T表示要转换的类型。表达式包括变量、复杂算子和函数返回值等. 比如计算直角三角形的斜边长时使用math包的Sqrt()函数，该函数接收的是float64类型的参数，而变量a和b都是int类型的，这个时候就需要将a和b强制类型转换为float64类型。 func sqrtDemo() { var a, b = 3, 4 var c int // math.Sqrt()接收的参数是float64类型，需要强制转换 c = int(math.Sqrt(float64(a*a + b*b))) fmt.Println(c) } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[],"author":"阮荣望"}],"categories":[],"tags":[]}